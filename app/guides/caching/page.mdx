# Caching

Catmint provides built-in caching primitives for route-level response caching, build-time pre-rendering, and programmatic cache invalidation. This guide covers `cachedRoute`, `staticRoute`, `invalidateCache`, the CacheStore interface, and CDN integration via cache headers.

## Route-Level Caching with cachedRoute

Use `cachedRoute()` from `catmint/cache` to cache the response of a route handler for a specified duration. The first argument is the TTL (time-to-live) in seconds, and the second is the handler function:

```ts
// app/api/posts/endpoint.ts
import { cachedRoute } from 'catmint/cache'
import { db } from '../../lib/db.server'

// Cache the response for 60 seconds
export const GET = cachedRoute(60, async (request) => {
  const posts = await db.post.findMany({
    orderBy: { createdAt: 'desc' },
    take: 20,
  })

  return Response.json(posts)
})
```

When a cached response exists and has not expired, the handler is skipped entirely and the cached response is returned. After the TTL elapses, the next request triggers the handler again and refreshes the cache.

### Caching with Dynamic Keys

By default, the cache key is derived from the request URL (including query parameters). Different URLs produce different cache entries:

```ts
// app/api/posts/[slug]/endpoint.ts
import { cachedRoute } from 'catmint/cache'
import { db } from '../../../lib/db.server'

// Each unique slug gets its own cache entry
export const GET = cachedRoute(300, async (request, { params }) => {
  const post = await db.post.findUnique({
    where: { slug: params.slug },
  })

  if (!post) {
    return new Response('Not found', { status: 404 })
  }

  return Response.json(post)
})
```

## Build-Time Pre-Rendering with staticRoute

Use `staticRoute()` to pre-render a route at build time. The handler runs once during `catmint build` and the result is saved as a static file:

```ts
// app/api/config/endpoint.ts
import { staticRoute } from 'catmint/cache'

export const GET = staticRoute(async () => {
  return Response.json({
    version: '1.0.0',
    features: ['rsc', 'streaming', 'middleware'],
    buildTime: new Date().toISOString(),
  })
})
```

Static routes are ideal for content that does not change between deployments: configuration endpoints, sitemap generation, RSS feeds, or marketing pages with infrequent updates.

> Static routes cannot access runtime request data (headers, cookies, query parameters) because they are rendered at build time, not at request time.

## Cache Invalidation with invalidateCache

Use `invalidateCache()` from `catmint/cache` to programmatically clear cached responses. It accepts a glob-style pattern to match cache keys:

```ts
// app/api/posts/endpoint.ts
import { invalidateCache } from 'catmint/cache'
import { db } from '../../lib/db.server'

export async function POST(request: Request) {
  const body = await request.json()

  const post = await db.post.create({
    data: body,
  })

  // Invalidate all cached post routes
  await invalidateCache('/api/posts*')

  return Response.json(post, { status: 201 })
}
```

The pattern matching follows glob syntax:

| Pattern | Matches |
| --- | --- |
| `"/api/posts"` | Exact match only |
| `"/api/posts*"` | All routes starting with /api/posts |
| `"*"` | All cached entries (full cache clear) |

## The CacheStore Interface

Catmint uses an in-memory cache store by default. For production deployments, you can provide a custom cache store that implements the `CacheStore` interface:

```ts
interface CacheStore {
  get(key: string): Promise<CachedResponse | null>
  set(key: string, value: CachedResponse, ttl: number): Promise<void>
  delete(key: string): Promise<void>
  clear(pattern?: string): Promise<void>
}

interface CachedResponse {
  body: string
  status: number
  headers: Record<string, string>
}
```

### Custom Cache Store Example

```ts
// app/lib/redis-cache.server.ts
import type { CacheStore, CachedResponse } from 'catmint/cache'
import { Redis } from 'ioredis'

const redis = new Redis(process.env.REDIS_URL)

export const redisCacheStore: CacheStore = {
  async get(key) {
    const data = await redis.get(`cache:${key}`)
    return data ? JSON.parse(data) : null
  },

  async set(key, value, ttl) {
    await redis.setex(`cache:${key}`, ttl, JSON.stringify(value))
  },

  async delete(key) {
    await redis.del(`cache:${key}`)
  },

  async clear(pattern = '*') {
    const keys = await redis.keys(`cache:${pattern}`)
    if (keys.length > 0) {
      await redis.del(...keys)
    }
  },
}
```

### Registering a Custom Store

```ts
// catmint.config.ts
import { defineConfig } from 'catmint/config'
import { redisCacheStore } from './app/lib/redis-cache.server'

export default defineConfig({
  mode: 'fullstack',
  cache: {
    store: redisCacheStore,
  },
})
```

## Cache Headers for CDN Integration

For deployments behind a CDN (Cloudflare, Vercel, Fastly, etc.), set standard cache headers on responses to leverage edge caching:

```ts
// app/api/products/endpoint.ts
import { db } from '../../lib/db.server'

export async function GET() {
  const products = await db.product.findMany()

  return new Response(JSON.stringify(products), {
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'public, max-age=60, s-maxage=300, stale-while-revalidate=600',
    },
  })
}
```

| Directive | Description |
| --- | --- |
| `max-age` | How long the browser may cache the response (seconds) |
| `s-maxage` | How long a shared cache (CDN) may cache the response |
| `stale-while-revalidate` | Serve stale content while revalidating in the background |
| `no-store` | Disable caching entirely (for sensitive data) |

### Combining cachedRoute with CDN Headers

You can use `cachedRoute` for server-side caching and set `Cache-Control` headers for CDN-level caching. They operate independently:

```ts
// app/api/feed/endpoint.ts
import { cachedRoute } from 'catmint/cache'
import { db } from '../../lib/db.server'

export const GET = cachedRoute(120, async () => {
  const items = await db.feedItem.findMany({ take: 50 })

  return new Response(JSON.stringify(items), {
    headers: {
      'Content-Type': 'application/json',
      // Server cache: 120s (from cachedRoute)
      // CDN cache: 300s
      // Browser cache: 60s
      'Cache-Control': 'public, max-age=60, s-maxage=300',
    },
  })
})
```

## Next Steps

- [API Endpoints](/guides/api-endpoints) -- build HTTP handlers that you can cache
- [Server Functions](/guides/server-functions) -- server-side logic with createServerFn
- [Middleware](/guides/middleware) -- add cache headers globally via middleware
