import { cachedRoute } from "catmint/cache";
import { CacheDemo } from "./cache-demo.client";

/**
 * This page is wrapped with cachedRoute(). The first request executes the
 * handler and caches the result. Subsequent requests within the TTL
 * serve the cached result. After the TTL, stale-while-revalidate serves
 * the old result while refreshing in the background.
 */
export default cachedRoute(
  async function CachedRoutePage() {
    // Simulate an expensive data fetch
    await new Promise((r) => setTimeout(r, 200));

    const data = {
      generatedAt: new Date().toISOString(),
      randomValue: Math.random().toFixed(6),
      pid: process.pid,
    };

    return (
      <div>
        <h1>Cached Route</h1>
        <p>
          <code>cachedRoute()</code> wraps a page with an in-memory cache. The
          handler runs once, and subsequent requests serve the cached result
          until the TTL expires.
        </p>

        <h2>Cached Server Data</h2>
        <div className="mt-3 p-4 bg-green-50 border border-green-200 rounded">
          <div className="text-sm text-gray-600 mb-2">
            This data was generated by the server handler. Refresh the page
            within 30 seconds â€” you&apos;ll see the same values (cache hit).
          </div>
          <div className="font-mono text-sm space-y-1">
            <div>generatedAt: {data.generatedAt}</div>
            <div>randomValue: {data.randomValue}</div>
            <div>pid: {data.pid}</div>
          </div>
          <div className="text-xs text-gray-400 mt-2">
            After 30 seconds, the next request triggers background revalidation
            (stale-while-revalidate). You&apos;ll get the stale data immediately
            while the cache refreshes.
          </div>
        </div>

        <h2 className="mt-8">Cache Invalidation</h2>
        <p>
          Use <code>invalidateCache()</code> to clear cached entries by tag or
          route. The button below calls a server function that invalidates the
          cache for this page.
        </p>
        <CacheDemo />

        <div className="mt-8 p-4 bg-gray-50 rounded border">
          <h3 className="font-semibold text-sm mb-2">Usage</h3>
          <pre className="text-sm bg-gray-900 text-gray-100 p-4 rounded overflow-auto">
            {`import { cachedRoute, invalidateCache } from "catmint/cache"

// Cache for 30 seconds with a tag
export default cachedRoute(
  async function MyPage() {
    const data = await fetchExpensiveData()
    return <div>{data}</div>
  },
  {
    tag: ["my-page"],
    revalidate: 30,
    staleWhileRevalidate: true, // default
  }
)

// Invalidate by tag:
await invalidateCache({ tag: "my-page" })

// Invalidate by route:
await invalidateCache({ route: "/my-page" })`}
          </pre>
          <ul className="text-sm text-gray-700 space-y-1 list-disc list-inside mt-3">
            <li>
              <code>revalidate</code>: TTL in seconds before cache is stale
            </li>
            <li>
              <code>tag</code>: string array for targeted invalidation
            </li>
            <li>
              <code>staleWhileRevalidate</code>: serve stale data while
              refreshing in background (default: true)
            </li>
            <li>Cache key is derived from the handler name + arguments</li>
          </ul>
        </div>
      </div>
    );
  },
  {
    tag: ["cached-demo"],
    revalidate: 30,
  },
);
